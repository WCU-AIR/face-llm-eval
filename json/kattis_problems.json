{
  "10kindsofpeople": {
    "id": "10kindsofpeople",
    "url": "https://open.kattis.com/problems/10kindsofpeople",
    "difficulty_elo": 3.8,
    "difficulty_cat": "Medium",
    "description": "Image by Christiaan Colen   The world is made up of $10$ kinds of people, those who understand binary and those who do not. These different kinds of people do not always get along so well. Bob might ask for a $10000$ ounce coffee (meaning binary) and Alice might make misinterpret his request as being in decimal and give him a $10011100010000$ ounce coffee (binary). After Sue explains that this much coffee costs $100$ dollars (decimal), Bob might assume he only has to pay $4$ dollars (interpreting the price as being in binary). In response to these differences that are difficult to resolve, these two groups have divided the world into two regions, the binary-friendly zones and the decimal-friendly zones. They have even published a map like the following to help people keep up with where the areas are (they have used ones and zeros so nobody would have trouble reading it).  1111100000 1111000000 1110000011 0111100111 0011111111  Users of binary have to stay in the zones marked with a zero. Users of decimal have to stay in the zones marked with a one. You have to figure out if it is possible for either type of person to get between various locations of interest. People can move north, south, east or west, but cannot move   Input Input starts with a line containing two positive integers, $1 \\le r \\le 1\\, 000$ and $1 \\le c \\le 1\\, 000$. The next $r$ input lines give the contents of the map, each line containing exactly $c$ characters (which are all chosen from $0$ or $1$). The next line has an integer $0 \\le n \\le 1\\, 000$. The following $n$ lines each contain one query, given as four integers: $r_1,c_1$ and $r_2,c_2$. These two pairs indicate two locations on the map, and their limits are $1 \\le r_1, r_2 \\le r$ and $1 \\le c_1, c_2 \\le c$. Output For each query, output binary if a binary user can start from location $r_1, c_1$ and move to location $r_2, c_2$. Output decimal if a decimal user can move between the two locations. Otherwise, output neither.",
    "tests": "Test Cases:\nSample Input 1\nSample Output 1\n\n\n\n\n1 4\n1100\n2\n1 1 1 4\n1 1 1 1\n\n\n\n\nneither\ndecimal\n\n\n\n\n\n\nSample Input 2\nSample Output 2\n\n\n\n\n10 20\n11111111111111111111\n11000000000000000101\n11111111111111110000\n11111111111111110000\n11000000000000000111\n00011111111111111111\n00111111111111111111\n10000000000000001111\n11111111111111111111\n11111111111111111111\n3\n2 3 8 16\n8 1 7 3\n1 1 10 20\n\n\n\n\nbinary\ndecimal\nneither"
  },
  "1dfroggereasy": {
    "id": "1dfroggereasy",
    "url": "https://open.kattis.com/problems/1dfroggereasy",
    "difficulty_elo": 3.3,
    "difficulty_cat": "Medium",
    "description": "Image by alptraum (iStock); Used under license   Frogger is a classic $2$-D video game that challenges the player to move a frog character safely across a traffic-filled road and a hazardous river. What is not well known is that Frogger actually began as a prototype board game based on a $1$-D concept at a now-defunct toy company.1 After spending millions of dollars following the advice of consultants, company executives realized that the resulting game was almost completely deterministic, and therefore not much fun to play,2 so they sold all Frogger rights to a video game company in an attempt to recoup some of the development costs. The rest, as they say, is video game history. The original $1$-D Frogger design, however, makes for good programming competition problems. Here is how the game works. The board is a row of $n$ squares, each of which contains a non-zero integer. These squares are indexed $1, 2, \\ldots , n$, from left to right. To start the game, the player rolls an $n$-sided die with one of the distinct indices on each side, and places a frog token on the board square with the resulting index. The player then randomly selects a card from a deck of cards with integers written on them (one per card); the integer on each card is contained in at least one board square. The number on the selected card is the magic number (or goal number) for this instance of the game. The player then applies the following rule as many times as necessary until the game ends:   If the frog is on a square containing a positive integer, $k$, the frog makes a length-$k$ hop to the right. (Hop distance is measured in board square units.)   If the frog is on a square containing a negative integer, $k$, the frog makes a length-$|k|$ hop to the left (note the absolute value).   The game ends as soon as the frog encounters one of the following four fates:   The frog lands on a square containing the magic number. This is the only winning outcome for the player. Note that if the frog starts on a square containing the magic number, the player wins immediately (i.e., after\u00a0$0$ hops).   The frog falls off the left end of the board.   The frog falls off the right end of the board.   The frog hops onto a square where the frog has been before, and therefore is trapped in a cycle.   Let $h \\geq 0$ be the number of hops the frog makes before the game ends. Given an instance of the game, your task is to determine the frog\u2019s fate   Input The first line of input contains three space-separated integers, $n$, $s$, $m$, where $n$ is the number of board squares $(1 \\leq n \\leq 200)$, $s$ is the index of the frog\u2019s starting square $(1 \\leq s \\leq n)$, and $m$ is the magic number. This is followed by a line containing $n$ space-separated non-zero integers. These are the numbers in the board squares in order from left to right. Each board square number is in the interval $[-200, 200]$, and the magic number is guaranteed to be one of the board square numbers. Output Output two lines. The first line contains a word indicating the fate of the frog, one of $\\{ $\u2018magic\u2019, \u2018left\u2019, \u2018right\u2019, \u2018cycle\u2019$\\} $, corresponding to the four fates listed above, respectively. The second line contains the integer\u00a0$h$, the number of hops the frog makes before encountering its fate.",
    "tests": "Test Cases:\nSample Input 1\nSample Output 1\n\n\n\n6 4 42\n-9 1 42 -2 -3 -3\n\n\n\nmagic\n2\n\n\n\n\n\n\nSample Input 2\nSample Output 2\n\n\n\n8 2 13\n7 5 4 2 13 -2 -3 6\n\n\n\ncycle\n4"
  }
}